# 공부내용 


> ⚡1712번 | 손익분기점
> ------------
>  풀이
```
간단한 수학문제를 코드로 구현하면 된다.
조심할 점은 if문으로 분모가 0이되는 경우를 예외처리해주어야한다.
```
> ⚡2292번 | 벌집
> ------------
>  풀이
```
입력으로 주어진 숫자가 어느 레이어 6의배수 어떤값보다 크고 6의배수 어떤값보다 작느냐를 찾는 문제라고 생각했다.
그래서 초기값 정중앙일때의 값과 답을 1로 초기화를 해주었고 while 문으로 
숫자가 i보다 작아질때 까지 돌렸다.
i는 6*답 씩 커진다.
답은 1씩 커진다.
그러다 6*답이 숫자보다 커지면 
답을 출력한다.
```
> ⚡1193번 | 분수찾기
> ------------
>  풀이
```
1/1 ->    1/2 -> 2/1 ->    3/1 -> 2/2 -> 1/3


1개 2개 3개 이런식으로 n개씩 늘어난다고 친다면


홀수씩 늘어날 때는 분자는 n부터 1까지 줄어들고 분모는 1부터 n까지 늘어난다.

짝수씩 늘어날 때는 분자는 1부터 n까지 늘어나고 분모는 n부터 1까지 줄어든다.

14는 (1 + 2+ 3+ 4) < 14 < (1 + 2 + 3 + 4 + 5) 사이에 있는 수이다.
 
그렇다면 굳이 i와 j를 num_count가 10번째가 되기 이전에 계속 바꿀 필요가 없다는 뜻이다.
 
x = 14일 때 첫 번째 while문이 종료될 때 num_count = 15, num = 5이다.
 
그래서 num_count에서 num만큼 빼준후에 거기서부터 i와 j를 찾아주면 되는것이다.

이 때, num이 홀수이기 때문에 앞서 말했던 규칙을 따르면

홀수씩 늘어날 때는 분자는 n부터 1까지 줄어들고 분모는 1부터 n까지 늘어난다.
```
> ⚡2869번 | 달팽이는 올라가고 싶다.
> ------------
>  풀이
```
#원래 작성했던 답 근데 시간초과 가 나니 이걸 수식으로 정리해서 풀어야함
# 전진,후진,높이=map(int,input().split())
# 답 = 1
# 간거리 = 0
# while True:
#     간거리 = 간거리 + 전진
#     if 간거리 < 높이:
#         간거리 = 간거리 - 후진
#         답 = 답 + 1
#         print(답)
#     else:
#         print("진짜답")
#         print(답)
#         break
식
전진 * 답 - 후진 * 답 - 1 = 높이
인데 이것을 이항시켜 답이 바로 나오게 하면 된다.
```
> ⚡10250번 | ACM호텔
> ------------
>  풀이
```
이 문제는 
손님을 첫번째 방(1호실) 부터 채워지는것을 계산하는 것이다.
층수,호수,방문한순서 세개를 받아서 규칙을 찾아보면
방문한순서를 층수로 나누면 나머지가 층수가 되고
방문한순서를 층수로 나눈 몫이 호수가 된다.
단 방문한순서가 층수의 배수이면 딱 떨어지기 때문에
가장 높은 층을 줘어야 하는것을 생각해야한다.
```
> ⚡2775번 | 부녀회장이 될테야
> ------------
>  풀이
```
다시 공부해야함
```
> ⚡2839번 | 설탕 배달 
> ------------
>  풀이
```
5로 많이 나누어 질때 가장 적게 봉지가 만들어진다
그렇기에 5의 배수일 경우에 나눈 몫을 답에 더하고(5kg 봉지)
5의 배수가 아닐경우에 계속 3씩 빼준 후 답에 1씩 더하고(3kg봉지)
결국 5의 배수일때 if를 타서 답을 출력하게 만들어준다.
```
> ⚡10757번 | 큰 수 A+B
> ------------
>  풀이
```
(풀이내용)
```
> ⚡1011번 | Fly me to the Alpha Centauri
> ------------
>  풀이
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FETKwh%2FbtqFWdlQm1f%2FUWsibXsc7MULuYdTEoAv2k%2Fimg.jpg" >
```
위 표는 이 문제를 풀 때 필요한 거리, 경로, 이동 회수를 정리한 표이다. 위 표에서 보면 이동 회수 (count)의 숫자가 증가할 때 일정한 규칙을 갖고 증가하는 것을 볼 수 있다. 

이동 회수(count)를 보면 1이 1번, 2가 1번, 3이 2번, 4가 2번, 5가 3번, 6이 3번 이런 식으로 나타나는 것을 볼 수 있다. 즉 이동 회수를 나타내는 숫자의 빈도수가 1,1,2,2,3,3,4,4, 이런 식으로 두 번씩 나타나는 규칙을 찾을 수 있다.

이 빈도수에 해당하는 수를 더한 합은 count 숫자에 따라 이동 가능한 최대 거리를 나타낸다. 예를 들어 count가 6을 나타낸다면 count 6까지 우측 move distance 숫자를 합하면 12가 된다. (1+1+2+2+3+3 = 12) 

```
